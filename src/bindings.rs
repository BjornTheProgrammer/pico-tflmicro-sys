/* automatically generated by rust-bindgen 0.69.4 */

#[allow(non_snake_case, non_camel_case_types, non_upper_case_globals)]
pub mod root {
    #[repr(C)]
    #[derive(Default)]
    pub struct __IncompleteArrayField<T>(::core::marker::PhantomData<T>, [T; 0]);
    impl<T> __IncompleteArrayField<T> {
        #[inline]
        pub const fn new() -> Self {
            __IncompleteArrayField(::core::marker::PhantomData, [])
        }
        #[inline]
        pub fn as_ptr(&self) -> *const T {
            self as *const _ as *const T
        }
        #[inline]
        pub fn as_mut_ptr(&mut self) -> *mut T {
            self as *mut _ as *mut T
        }
        #[inline]
        pub unsafe fn as_slice(&self, len: usize) -> &[T] {
            ::core::slice::from_raw_parts(self.as_ptr(), len)
        }
        #[inline]
        pub unsafe fn as_mut_slice(&mut self, len: usize) -> &mut [T] {
            ::core::slice::from_raw_parts_mut(self.as_mut_ptr(), len)
        }
    }
    impl<T> ::core::fmt::Debug for __IncompleteArrayField<T> {
        fn fmt(&self, fmt: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
            fmt.write_str("__IncompleteArrayField")
        }
    }
    #[repr(C)]
    pub struct __BindgenUnionField<T>(::core::marker::PhantomData<T>);
    impl<T> __BindgenUnionField<T> {
        #[inline]
        pub const fn new() -> Self {
            __BindgenUnionField(::core::marker::PhantomData)
        }
        #[inline]
        pub unsafe fn as_ref(&self) -> &T {
            ::core::mem::transmute(self)
        }
        #[inline]
        pub unsafe fn as_mut(&mut self) -> &mut T {
            ::core::mem::transmute(self)
        }
    }
    impl<T> ::core::default::Default for __BindgenUnionField<T> {
        #[inline]
        fn default() -> Self {
            Self::new()
        }
    }
    impl<T> ::core::clone::Clone for __BindgenUnionField<T> {
        #[inline]
        fn clone(&self) -> Self {
            *self
        }
    }
    impl<T> ::core::marker::Copy for __BindgenUnionField<T> {}
    impl<T> ::core::fmt::Debug for __BindgenUnionField<T> {
        fn fmt(&self, fmt: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
            fmt.write_str("__BindgenUnionField")
        }
    }
    impl<T> ::core::hash::Hash for __BindgenUnionField<T> {
        fn hash<H: ::core::hash::Hasher>(&self, _state: &mut H) {}
    }
    impl<T> ::core::cmp::PartialEq for __BindgenUnionField<T> {
        fn eq(&self, _other: &__BindgenUnionField<T>) -> bool {
            true
        }
    }
    impl<T> ::core::cmp::Eq for __BindgenUnionField<T> {}
    #[allow(unused_imports)]
    use self::super::root;
    pub mod std {
        #[allow(unused_imports)]
        use self::super::super::root;
        #[repr(C)]
        pub struct basic_string<_CharT> {
            pub _M_dataplus: root::std::basic_string__Alloc_hider,
            pub _M_string_length: root::std::basic_string_size_type,
            pub __bindgen_anon_1: root::std::basic_string__bindgen_ty_2<_CharT>,
            pub _phantom_0: ::core::marker::PhantomData<::core::cell::UnsafeCell<_CharT>>,
        }
        pub type basic_string__Char_alloc_type = [u8; 0usize];
        pub type basic_string__Alloc_traits = root::__gnu_cxx::__alloc_traits;
        pub type basic_string_traits_type<_Traits> = _Traits;
        pub type basic_string_value_type = [u8; 0usize];
        pub type basic_string_allocator_type = root::std::basic_string__Char_alloc_type;
        pub type basic_string_size_type = [u8; 0usize];
        pub type basic_string_difference_type = [u8; 0usize];
        pub type basic_string_reference = [u8; 0usize];
        pub type basic_string_const_reference = [u8; 0usize];
        pub type basic_string_pointer = [u8; 0usize];
        pub type basic_string_const_pointer = [u8; 0usize];
        pub type basic_string_iterator =
            root::__gnu_cxx::__normal_iterator<root::std::basic_string_pointer>;
        pub type basic_string_const_iterator =
            root::__gnu_cxx::__normal_iterator<root::std::basic_string_const_pointer>;
        pub type basic_string_const_reverse_iterator =
            root::std::reverse_iterator<root::std::basic_string_const_iterator>;
        pub type basic_string_reverse_iterator =
            root::std::reverse_iterator<root::std::basic_string_iterator>;
        pub type basic_string___const_iterator = root::std::basic_string_const_iterator;
        #[repr(C)]
        pub struct basic_string__Alloc_hider {
            pub _M_p: root::std::basic_string_pointer,
        }
        impl Default for basic_string__Alloc_hider {
            fn default() -> Self {
                let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
                unsafe {
                    ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
                    s.assume_init()
                }
            }
        }
        impl ::core::fmt::Debug for basic_string__Alloc_hider {
            fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                write!(f, "basic_string__Alloc_hider {{  }}")
            }
        }
        pub const basic_string__S_local_capacity: root::std::basic_string__bindgen_ty_1 =
            basic_string__bindgen_ty_1::_S_local_capacity;
        #[repr(i32)]
        #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
        pub enum basic_string__bindgen_ty_1 {
            _S_local_capacity = 0,
        }
        #[repr(C)]
        pub struct basic_string__bindgen_ty_2<_CharT> {
            pub _M_local_buf: root::__BindgenUnionField<*mut _CharT>,
            pub _M_allocated_capacity: root::__BindgenUnionField<root::std::basic_string_size_type>,
            pub bindgen_union_field: u32,
            pub _phantom_0: ::core::marker::PhantomData<::core::cell::UnsafeCell<_CharT>>,
        }
        impl<_CharT> Default for basic_string__bindgen_ty_2<_CharT> {
            fn default() -> Self {
                let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
                unsafe {
                    ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
                    s.assume_init()
                }
            }
        }
        impl<_CharT> ::core::fmt::Debug for basic_string__bindgen_ty_2<_CharT> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                write!(f, "basic_string__bindgen_ty_2 {{ union }}")
            }
        }
        impl<_CharT> Default for basic_string<_CharT> {
            fn default() -> Self {
                let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
                unsafe {
                    ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
                    s.assume_init()
                }
            }
        }
        impl<_CharT> ::core::fmt::Debug for basic_string<_CharT> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                write!(
                    f,
                    "basic_string {{ _M_dataplus: {:?}, __bindgen_anon_1: {:?} }}",
                    self._M_dataplus, self.__bindgen_anon_1
                )
            }
        }
        pub type integral_constant_value_type<_Tp> = _Tp;
        pub type integral_constant_type = u8;
        pub type true_type = u8;
        pub type false_type = u8;
        pub type __bool_constant = u8;
        #[repr(C)]
        #[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
        pub struct __and_ {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
        pub struct is_empty {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
        pub struct is_same {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
        pub struct make_unsigned {
            pub _address: u8,
        }
        pub type make_unsigned_type = u8;
        #[repr(C)]
        #[derive(Copy, Clone)]
        pub union aligned_storage_type {
            pub __data: *mut cty::c_uchar,
            pub __align: root::std::aligned_storage_type__bindgen_ty_1,
        }
        #[repr(C)]
        #[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
        pub struct aligned_storage_type__bindgen_ty_1 {
            pub _address: u8,
        }
        impl Default for aligned_storage_type {
            fn default() -> Self {
                let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
                unsafe {
                    ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
                    s.assume_init()
                }
            }
        }
        impl ::core::fmt::Debug for aligned_storage_type {
            fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                write!(f, "aligned_storage_type {{ union }}")
            }
        }
        pub type __enable_if_t = u8;
        pub type conditional_type<_Iftrue> = _Iftrue;
        #[repr(C)]
        #[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
        pub struct __detector {
            pub _address: u8,
        }
        pub type __detector_value_t = root::std::false_type;
        pub type __detector_type<_Default> = _Default;
        pub type __detected_or = root::std::__detector;
        pub type __detected_or_t = root::std::__detected_or;
        #[repr(C)]
        #[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
        pub struct input_iterator_tag {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
        pub struct forward_iterator_tag {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
        pub struct bidirectional_iterator_tag {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
        pub struct iterator {
            pub _address: u8,
        }
        pub type iterator_iterator_category<_Category> = _Category;
        pub type iterator_value_type<_Tp> = _Tp;
        pub type iterator_difference_type<_Distance> = _Distance;
        pub type iterator_pointer<_Pointer> = _Pointer;
        pub type iterator_reference<_Reference> = _Reference;
        #[repr(C)]
        #[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
        pub struct __iterator_traits {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
        pub struct iterator_traits {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct __undefined {
            _unused: [u8; 0],
        }
        #[repr(C)]
        #[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
        pub struct __get_first_arg {
            pub _address: u8,
        }
        pub type __get_first_arg_type = root::std::__undefined;
        pub type __get_first_arg_t = root::std::__get_first_arg;
        #[repr(C)]
        #[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
        pub struct __replace_first_arg {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
        pub struct pointer_traits {
            pub _address: u8,
        }
        pub type pointer_traits___element_type = [u8; 0usize];
        pub type pointer_traits___difference_type = [u8; 0usize];
        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq, Eq)]
        pub struct pointer_traits___rebind {
            pub _address: u8,
        }
        impl Default for pointer_traits___rebind {
            fn default() -> Self {
                let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
                unsafe {
                    ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
                    s.assume_init()
                }
            }
        }
        pub type pointer_traits_pointer<_Ptr> = _Ptr;
        pub type pointer_traits_element_type = root::std::__detected_or_t;
        pub type pointer_traits_difference_type = root::std::__detected_or_t;
        pub type pointer_traits_rebind = root::std::pointer_traits___rebind;
        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq, Eq)]
        pub struct reverse_iterator<_Iterator> {
            pub current: _Iterator,
            pub _phantom_0: ::core::marker::PhantomData<::core::cell::UnsafeCell<_Iterator>>,
        }
        pub type reverse_iterator___traits_type = root::std::iterator_traits;
        pub type reverse_iterator_iterator_type<_Iterator> = _Iterator;
        pub type reverse_iterator_pointer = root::std::reverse_iterator___traits_type;
        pub type reverse_iterator_difference_type = root::std::reverse_iterator___traits_type;
        pub type reverse_iterator_reference = root::std::reverse_iterator___traits_type;
        impl<_Iterator> Default for reverse_iterator<_Iterator> {
            fn default() -> Self {
                let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
                unsafe {
                    ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
                    s.assume_init()
                }
            }
        }
        pub type __allocator_base = root::__gnu_cxx::new_allocator;
        #[repr(C)]
        #[derive(Debug, PartialEq, Eq)]
        pub struct allocator {
            pub _address: u8,
        }
        pub type allocator_value_type<_Tp> = _Tp;
        pub type allocator_size_type = usize;
        pub type allocator_difference_type = isize;
        pub type allocator_pointer<_Tp> = *mut _Tp;
        pub type allocator_const_pointer<_Tp> = *const _Tp;
        pub type allocator_reference<_Tp> = *mut _Tp;
        pub type allocator_const_reference<_Tp> = *const _Tp;
        #[repr(C)]
        #[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
        pub struct allocator_rebind {
            pub _address: u8,
        }
        pub type allocator_rebind_other = root::std::allocator;
        pub type allocator_propagate_on_container_move_assignment = root::std::true_type;
        pub type allocator_is_always_equal = root::std::true_type;
        impl Default for allocator {
            fn default() -> Self {
                let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
                unsafe {
                    ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
                    s.assume_init()
                }
            }
        }
        #[repr(C)]
        #[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
        pub struct __allocator_traits_base {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq, Eq)]
        pub struct __allocator_traits_base___rebind {
            pub _address: u8,
        }
        impl Default for __allocator_traits_base___rebind {
            fn default() -> Self {
                let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
                unsafe {
                    ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
                    s.assume_init()
                }
            }
        }
        pub type __allocator_traits_base___pointer = [u8; 0usize];
        pub type __allocator_traits_base___c_pointer = [u8; 0usize];
        pub type __allocator_traits_base___v_pointer = [u8; 0usize];
        pub type __allocator_traits_base___cv_pointer = [u8; 0usize];
        pub type __allocator_traits_base___pocca = [u8; 0usize];
        pub type __allocator_traits_base___pocma = [u8; 0usize];
        pub type __allocator_traits_base___pocs = [u8; 0usize];
        pub type __allocator_traits_base___equal = [u8; 0usize];
        pub type __alloc_rebind = root::std::__allocator_traits_base;
        #[repr(C)]
        #[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
        pub struct allocator_traits {
            pub _address: u8,
        }
        pub type allocator_traits_allocator_type<_Alloc> = _Alloc;
        pub type allocator_traits_value_type = [u8; 0usize];
        pub type allocator_traits_pointer = root::std::__detected_or_t;
        #[repr(C)]
        #[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
        pub struct allocator_traits__Ptr {
            pub _address: u8,
        }
        pub type allocator_traits__Ptr_type = [u8; 0usize];
        #[repr(C)]
        #[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
        pub struct allocator_traits__Diff {
            pub _address: u8,
        }
        pub type allocator_traits__Diff_type = root::std::pointer_traits;
        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq, Eq)]
        pub struct allocator_traits__Size {
            pub _address: u8,
        }
        impl Default for allocator_traits__Size {
            fn default() -> Self {
                let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
                unsafe {
                    ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
                    s.assume_init()
                }
            }
        }
        pub type allocator_traits_const_pointer = [u8; 0usize];
        pub type allocator_traits_void_pointer = root::std::allocator_traits__Ptr;
        pub type allocator_traits_const_void_pointer = root::std::allocator_traits__Ptr;
        pub type allocator_traits_difference_type = [u8; 0usize];
        pub type allocator_traits_size_type = [u8; 0usize];
        pub type allocator_traits_propagate_on_container_copy_assignment =
            root::std::__detected_or_t;
        pub type allocator_traits_propagate_on_container_move_assignment =
            root::std::__detected_or_t;
        pub type allocator_traits_propagate_on_container_swap = root::std::__detected_or_t;
        pub type allocator_traits_is_always_equal = root::std::__detected_or_t;
        pub type allocator_traits_rebind_alloc = root::std::__alloc_rebind;
        pub type allocator_traits_rebind_traits = root::std::allocator_traits;
        #[repr(C)]
        #[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
        pub struct allocator_traits___construct_helper {
            pub _address: u8,
        }
        pub type allocator_traits___construct_helper_type<_Alloc> = _Alloc;
        pub type allocator_traits___has_construct = root::std::allocator_traits___construct_helper;
        pub type string = root::std::basic_string<cty::c_char>;
        pub type streamoff = cty::c_longlong;
        #[repr(C)]
        #[derive(Debug, PartialEq, Eq)]
        pub struct fpos<_StateT> {
            pub _M_off: root::std::streamoff,
            pub _M_state: _StateT,
            pub _phantom_0: ::core::marker::PhantomData<::core::cell::UnsafeCell<_StateT>>,
        }
        impl<_StateT> Default for fpos<_StateT> {
            fn default() -> Self {
                let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
                unsafe {
                    ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
                    s.assume_init()
                }
            }
        }
        pub type streampos = root::std::fpos<root::_mbstate_t>;
        #[repr(C)]
        #[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
        pub struct unary_function {
            pub _address: u8,
        }
        pub type unary_function_argument_type<_Arg> = _Arg;
        pub type unary_function_result_type<_Result> = _Result;
        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq, Eq)]
        pub struct _Identity {
            pub _address: u8,
        }
        impl Default for _Identity {
            fn default() -> Self {
                let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
                unsafe {
                    ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
                    s.assume_init()
                }
            }
        }
        pub type _TupleConstraints_is_constructible = root::std::__bool_constant;
        #[repr(C)]
        #[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
        pub struct tuple {
            pub _address: u8,
        }
        pub type tuple__Inherited = u8;
        pub type tuple__TCC = u8;
        pub type tuple__ImplicitDefaultCtor = root::std::__enable_if_t;
        pub type tuple__ExplicitDefaultCtor = root::std::__enable_if_t;
        pub type tuple__ImplicitCtor = root::std::__enable_if_t;
        pub type tuple__ExplicitCtor = root::std::__enable_if_t;
        #[repr(C)]
        #[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
        pub struct tuple__UseOtherCtor {
            pub _base: root::std::false_type,
        }
        #[repr(C)]
        #[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
        pub struct default_delete {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
        pub struct __uniq_ptr_impl {
            pub _M_t: root::std::tuple,
        }
        #[repr(C)]
        #[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
        pub struct __uniq_ptr_impl__Ptr {
            pub _address: u8,
        }
        pub type __uniq_ptr_impl__Ptr_type<_Up> = *mut _Up;
        pub type __uniq_ptr_impl__DeleterConstraint = u8;
        pub type __uniq_ptr_impl_pointer = root::std::__uniq_ptr_impl__Ptr;
        #[repr(C)]
        #[derive(Debug, Default, PartialEq, Eq)]
        pub struct unique_ptr {
            pub _M_t: u8,
        }
        pub type unique_ptr__DeleterConstraint = root::std::__uniq_ptr_impl;
        pub type unique_ptr_pointer = root::std::__uniq_ptr_impl;
        pub type unique_ptr_element_type<_Tp> = _Tp;
        pub type unique_ptr_deleter_type<_Dp> = _Dp;
        pub type unique_ptr___safe_conversion_up = root::std::__and_;
        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq, Eq)]
        pub struct char_traits {
            pub _address: u8,
        }
        impl Default for char_traits {
            fn default() -> Self {
                let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
                unsafe {
                    ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
                    s.assume_init()
                }
            }
        }
        #[repr(C)]
        pub struct _Vector_base {
            pub _M_impl: root::std::_Vector_base__Vector_impl,
        }
        pub type _Vector_base__Tp_alloc_type = [u8; 0usize];
        pub type _Vector_base_pointer = [u8; 0usize];
        #[repr(C)]
        pub struct _Vector_base__Vector_impl_data {
            pub _M_start: root::std::_Vector_base_pointer,
            pub _M_finish: root::std::_Vector_base_pointer,
            pub _M_end_of_storage: root::std::_Vector_base_pointer,
        }
        impl Default for _Vector_base__Vector_impl_data {
            fn default() -> Self {
                let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
                unsafe {
                    ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
                    s.assume_init()
                }
            }
        }
        impl ::core::fmt::Debug for _Vector_base__Vector_impl_data {
            fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                write!(f, "_Vector_base__Vector_impl_data {{  }}")
            }
        }
        #[repr(C)]
        pub struct _Vector_base__Vector_impl {
            pub _base_1: root::std::_Vector_base__Vector_impl_data,
        }
        impl Default for _Vector_base__Vector_impl {
            fn default() -> Self {
                let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
                unsafe {
                    ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
                    s.assume_init()
                }
            }
        }
        impl ::core::fmt::Debug for _Vector_base__Vector_impl {
            fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                write!(f, "_Vector_base__Vector_impl {{  }}")
            }
        }
        pub type _Vector_base_allocator_type<_Alloc> = _Alloc;
        impl Default for _Vector_base {
            fn default() -> Self {
                let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
                unsafe {
                    ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
                    s.assume_init()
                }
            }
        }
        impl ::core::fmt::Debug for _Vector_base {
            fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                write!(f, "_Vector_base {{ _M_impl: {:?} }}", self._M_impl)
            }
        }
        #[repr(C)]
        pub struct vector {
            pub _base: root::std::_Vector_base,
        }
        pub type vector__Base = root::std::_Vector_base;
        pub type vector__Tp_alloc_type = root::std::vector__Base;
        pub type vector__Alloc_traits = root::__gnu_cxx::__alloc_traits;
        pub type vector_value_type<_Tp> = _Tp;
        pub type vector_pointer = root::std::vector__Base;
        pub type vector_const_pointer = root::std::vector__Alloc_traits;
        pub type vector_reference = root::std::vector__Alloc_traits;
        pub type vector_const_reference = root::std::vector__Alloc_traits;
        pub type vector_iterator = root::__gnu_cxx::__normal_iterator<root::std::vector_pointer>;
        pub type vector_const_iterator =
            root::__gnu_cxx::__normal_iterator<root::std::vector_const_pointer>;
        pub type vector_const_reverse_iterator =
            root::std::reverse_iterator<root::std::vector_const_iterator>;
        pub type vector_reverse_iterator = root::std::reverse_iterator<root::std::vector_iterator>;
        pub type vector_size_type = usize;
        pub type vector_difference_type = isize;
        pub type vector_allocator_type<_Alloc> = _Alloc;
        #[repr(C)]
        #[derive(Debug, PartialEq, Eq)]
        pub struct vector__Temporary_value {
            pub _M_this: *mut root::std::vector,
            pub __buf: u8,
        }
        impl Default for vector__Temporary_value {
            fn default() -> Self {
                let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
                unsafe {
                    ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
                    s.assume_init()
                }
            }
        }
        impl Default for vector {
            fn default() -> Self {
                let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
                unsafe {
                    ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
                    s.assume_init()
                }
            }
        }
        impl ::core::fmt::Debug for vector {
            fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                write!(f, "vector {{  }}")
            }
        }
        #[repr(u32)]
        #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
        pub enum _Rb_tree_color {
            _S_red = 0,
            _S_black = 1,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq, Eq)]
        pub struct _Rb_tree_node_base {
            pub _M_color: root::std::_Rb_tree_color,
            pub _M_parent: root::std::_Rb_tree_node_base__Base_ptr,
            pub _M_left: root::std::_Rb_tree_node_base__Base_ptr,
            pub _M_right: root::std::_Rb_tree_node_base__Base_ptr,
        }
        pub type _Rb_tree_node_base__Base_ptr = *mut root::std::_Rb_tree_node_base;
        pub type _Rb_tree_node_base__Const_Base_ptr = *const root::std::_Rb_tree_node_base;
        impl Default for _Rb_tree_node_base {
            fn default() -> Self {
                let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
                unsafe {
                    ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
                    s.assume_init()
                }
            }
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq, Eq)]
        pub struct _Rb_tree_key_compare<_Key_compare> {
            pub _M_key_compare: _Key_compare,
            pub _phantom_0: ::core::marker::PhantomData<::core::cell::UnsafeCell<_Key_compare>>,
        }
        impl<_Key_compare> Default for _Rb_tree_key_compare<_Key_compare> {
            fn default() -> Self {
                let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
                unsafe {
                    ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
                    s.assume_init()
                }
            }
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq, Eq)]
        pub struct _Rb_tree_node {
            pub _base: root::std::_Rb_tree_node_base,
            pub _M_storage: root::__gnu_cxx::__aligned_membuf,
        }
        pub type _Rb_tree_node__Link_type = *mut root::std::_Rb_tree_node;
        impl Default for _Rb_tree_node {
            fn default() -> Self {
                let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
                unsafe {
                    ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
                    s.assume_init()
                }
            }
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq, Eq)]
        pub struct _Rb_tree_iterator {
            pub _M_node: root::std::_Rb_tree_iterator__Base_ptr,
        }
        pub type _Rb_tree_iterator_value_type<_Tp> = _Tp;
        pub type _Rb_tree_iterator_reference<_Tp> = *mut _Tp;
        pub type _Rb_tree_iterator_pointer<_Tp> = *mut _Tp;
        pub type _Rb_tree_iterator_iterator_category = root::std::bidirectional_iterator_tag;
        pub type _Rb_tree_iterator_difference_type = isize;
        pub type _Rb_tree_iterator__Self = root::std::_Rb_tree_iterator;
        pub type _Rb_tree_iterator__Base_ptr = root::std::_Rb_tree_node_base__Base_ptr;
        pub type _Rb_tree_iterator__Link_type = *mut root::std::_Rb_tree_node;
        impl Default for _Rb_tree_iterator {
            fn default() -> Self {
                let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
                unsafe {
                    ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
                    s.assume_init()
                }
            }
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq, Eq)]
        pub struct _Rb_tree_const_iterator {
            pub _M_node: root::std::_Rb_tree_const_iterator__Base_ptr,
        }
        pub type _Rb_tree_const_iterator_value_type<_Tp> = _Tp;
        pub type _Rb_tree_const_iterator_reference<_Tp> = *const _Tp;
        pub type _Rb_tree_const_iterator_pointer<_Tp> = *const _Tp;
        pub type _Rb_tree_const_iterator_iterator = root::std::_Rb_tree_iterator;
        pub type _Rb_tree_const_iterator_iterator_category = root::std::bidirectional_iterator_tag;
        pub type _Rb_tree_const_iterator_difference_type = isize;
        pub type _Rb_tree_const_iterator__Self = root::std::_Rb_tree_const_iterator;
        pub type _Rb_tree_const_iterator__Base_ptr = root::std::_Rb_tree_node_base__Const_Base_ptr;
        pub type _Rb_tree_const_iterator__Link_type = *const root::std::_Rb_tree_node;
        impl Default for _Rb_tree_const_iterator {
            fn default() -> Self {
                let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
                unsafe {
                    ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
                    s.assume_init()
                }
            }
        }
        #[repr(C)]
        #[derive(Debug, Default, PartialEq, Eq)]
        pub struct _Rb_tree {
            pub _M_impl: u8,
        }
        pub type _Rb_tree__Node_allocator = [u8; 0usize];
        pub type _Rb_tree__Alloc_traits = root::__gnu_cxx::__alloc_traits;
        pub type _Rb_tree__Base_ptr = *mut root::std::_Rb_tree_node_base;
        pub type _Rb_tree__Const_Base_ptr = *const root::std::_Rb_tree_node_base;
        pub type _Rb_tree__Link_type = *mut root::std::_Rb_tree_node;
        pub type _Rb_tree__Const_Link_type = *const root::std::_Rb_tree_node;
        #[repr(C)]
        #[derive(Debug, PartialEq, Eq)]
        pub struct _Rb_tree__Reuse_or_alloc_node {
            pub _M_root: root::std::_Rb_tree__Base_ptr,
            pub _M_nodes: root::std::_Rb_tree__Base_ptr,
            pub _M_t: *mut root::std::_Rb_tree,
        }
        impl Default for _Rb_tree__Reuse_or_alloc_node {
            fn default() -> Self {
                let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
                unsafe {
                    ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
                    s.assume_init()
                }
            }
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq, Eq)]
        pub struct _Rb_tree__Alloc_node {
            pub _M_t: *mut root::std::_Rb_tree,
        }
        impl Default for _Rb_tree__Alloc_node {
            fn default() -> Self {
                let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
                unsafe {
                    ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
                    s.assume_init()
                }
            }
        }
        pub type _Rb_tree_key_type<_Key> = _Key;
        pub type _Rb_tree_value_type<_Val> = _Val;
        pub type _Rb_tree_pointer<_Val> = *mut root::std::_Rb_tree_value_type<_Val>;
        pub type _Rb_tree_const_pointer<_Val> = *const root::std::_Rb_tree_value_type<_Val>;
        pub type _Rb_tree_reference<_Val> = *mut root::std::_Rb_tree_value_type<_Val>;
        pub type _Rb_tree_const_reference<_Val> = *const root::std::_Rb_tree_value_type<_Val>;
        pub type _Rb_tree_size_type = usize;
        pub type _Rb_tree_difference_type = isize;
        pub type _Rb_tree_allocator_type<_Alloc> = _Alloc;
        pub type _Rb_tree_reverse_iterator =
            root::std::reverse_iterator<root::std::_Rb_tree_iterator>;
        pub type _Rb_tree_const_reverse_iterator =
            root::std::reverse_iterator<root::std::_Rb_tree_const_iterator>;
        pub type _Rb_tree___same_value_type = root::std::is_same;
        pub type _Rb_tree__Rb_tree_impl__Base_key_compare<_Key_compare> =
            root::std::_Rb_tree_key_compare<_Key_compare>;
        #[repr(C)]
        pub struct set {
            pub _M_t: root::std::set__Rep_type,
        }
        pub type set_key_type<_Key> = _Key;
        pub type set_value_type<_Key> = _Key;
        pub type set_key_compare<_Compare> = _Compare;
        pub type set_value_compare<_Compare> = _Compare;
        pub type set_allocator_type<_Alloc> = _Alloc;
        pub type set__Key_alloc_type = [u8; 0usize];
        pub type set__Rep_type = root::std::_Rb_tree;
        pub type set__Alloc_traits = root::__gnu_cxx::__alloc_traits;
        pub type set_pointer = [u8; 0usize];
        pub type set_const_pointer = [u8; 0usize];
        pub type set_reference = [u8; 0usize];
        pub type set_const_reference = [u8; 0usize];
        pub type set_iterator = [u8; 0usize];
        pub type set_const_iterator = [u8; 0usize];
        pub type set_reverse_iterator = [u8; 0usize];
        pub type set_const_reverse_iterator = [u8; 0usize];
        pub type set_size_type = [u8; 0usize];
        pub type set_difference_type = [u8; 0usize];
        impl Default for set {
            fn default() -> Self {
                let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
                unsafe {
                    ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
                    s.assume_init()
                }
            }
        }
        impl ::core::fmt::Debug for set {
            fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                write!(f, "set {{ _M_t: {:?} }}", self._M_t)
            }
        }
    }
    pub mod __gnu_cxx {
        #[allow(unused_imports)]
        use self::super::super::root;
        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq, Eq)]
        pub struct __normal_iterator<_Iterator> {
            pub _M_current: _Iterator,
            pub _phantom_0: ::core::marker::PhantomData<::core::cell::UnsafeCell<_Iterator>>,
        }
        pub type __normal_iterator___traits_type = root::std::iterator_traits;
        pub type __normal_iterator_iterator_type<_Iterator> = _Iterator;
        pub type __normal_iterator_iterator_category =
            root::__gnu_cxx::__normal_iterator___traits_type;
        pub type __normal_iterator_value_type = root::__gnu_cxx::__normal_iterator___traits_type;
        pub type __normal_iterator_difference_type =
            root::__gnu_cxx::__normal_iterator___traits_type;
        pub type __normal_iterator_reference = root::__gnu_cxx::__normal_iterator___traits_type;
        pub type __normal_iterator_pointer = root::__gnu_cxx::__normal_iterator___traits_type;
        impl<_Iterator> Default for __normal_iterator<_Iterator> {
            fn default() -> Self {
                let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
                unsafe {
                    ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
                    s.assume_init()
                }
            }
        }
        #[repr(C)]
        #[derive(Debug, Default, PartialEq, Eq)]
        pub struct new_allocator {
            pub _address: u8,
        }
        pub type new_allocator_value_type<_Tp> = _Tp;
        pub type new_allocator_size_type = usize;
        pub type new_allocator_difference_type = isize;
        pub type new_allocator_pointer<_Tp> = *mut _Tp;
        pub type new_allocator_const_pointer<_Tp> = *const _Tp;
        pub type new_allocator_reference<_Tp> = *mut _Tp;
        pub type new_allocator_const_reference<_Tp> = *const _Tp;
        #[repr(C)]
        #[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
        pub struct new_allocator_rebind {
            pub _address: u8,
        }
        pub type new_allocator_propagate_on_container_move_assignment = root::std::true_type;
        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq, Eq)]
        pub struct __alloc_traits {
            pub _address: u8,
        }
        pub type __alloc_traits_allocator_type<_Alloc> = _Alloc;
        pub type __alloc_traits__Base_type = root::std::allocator_traits;
        pub type __alloc_traits_value_type = root::__gnu_cxx::__alloc_traits__Base_type;
        pub type __alloc_traits_pointer = root::__gnu_cxx::__alloc_traits__Base_type;
        pub type __alloc_traits_const_pointer = root::__gnu_cxx::__alloc_traits__Base_type;
        pub type __alloc_traits_size_type = root::__gnu_cxx::__alloc_traits__Base_type;
        pub type __alloc_traits_difference_type = root::__gnu_cxx::__alloc_traits__Base_type;
        pub type __alloc_traits_reference = *mut root::__gnu_cxx::__alloc_traits_value_type;
        pub type __alloc_traits_const_reference = *const root::__gnu_cxx::__alloc_traits_value_type;
        pub type __alloc_traits___is_custom_pointer = root::std::__and_;
        #[repr(C)]
        #[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
        pub struct __alloc_traits_rebind {
            pub _address: u8,
        }
        pub type __alloc_traits_rebind_other = root::__gnu_cxx::__alloc_traits__Base_type;
        impl Default for __alloc_traits {
            fn default() -> Self {
                let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
                unsafe {
                    ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
                    s.assume_init()
                }
            }
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq, Eq)]
        pub struct __aligned_membuf {
            pub _M_storage: *mut cty::c_uchar,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq, Eq)]
        pub struct __aligned_membuf__Tp2<_Tp> {
            pub _M_t: _Tp,
            pub _phantom_0: ::core::marker::PhantomData<::core::cell::UnsafeCell<_Tp>>,
        }
        impl<_Tp> Default for __aligned_membuf__Tp2<_Tp> {
            fn default() -> Self {
                let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
                unsafe {
                    ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
                    s.assume_init()
                }
            }
        }
        impl Default for __aligned_membuf {
            fn default() -> Self {
                let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
                unsafe {
                    ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
                    s.assume_init()
                }
            }
        }
        #[repr(C)]
        #[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
        pub struct _Char_types {
            pub _address: u8,
        }
        pub type _Char_types_int_type = cty::c_ulong;
        pub type _Char_types_pos_type = root::std::streampos;
        pub type _Char_types_off_type = root::std::streamoff;
        pub type _Char_types_state_type = root::_mbstate_t;
        #[repr(C)]
        #[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
        pub struct char_traits {
            pub _address: u8,
        }
        pub type char_traits_char_type<_CharT> = _CharT;
        pub type char_traits_int_type = root::__gnu_cxx::_Char_types;
        pub type char_traits_pos_type = root::__gnu_cxx::_Char_types;
        pub type char_traits_off_type = root::__gnu_cxx::_Char_types;
        pub type char_traits_state_type = root::__gnu_cxx::_Char_types;
    }
    pub type wint_t = cty::c_int;
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub struct _mbstate_t {
        pub __count: cty::c_int,
        pub __value: root::_mbstate_t__bindgen_ty_1,
    }
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub union _mbstate_t__bindgen_ty_1 {
        pub __wch: root::wint_t,
        pub __wchb: [cty::c_uchar; 4usize],
    }
    impl Default for _mbstate_t__bindgen_ty_1 {
        fn default() -> Self {
            let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
            unsafe {
                ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
                s.assume_init()
            }
        }
    }
    impl ::core::fmt::Debug for _mbstate_t__bindgen_ty_1 {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
            write!(f, "_mbstate_t__bindgen_ty_1 {{ union }}")
        }
    }
    impl Default for _mbstate_t {
        fn default() -> Self {
            let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
            unsafe {
                ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
                s.assume_init()
            }
        }
    }
    impl ::core::fmt::Debug for _mbstate_t {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
            write!(
                f,
                "_mbstate_t {{ __count: {:?}, __value: {:?} }}",
                self.__count, self.__value
            )
        }
    }
    pub mod flatbuffers {
        #[allow(unused_imports)]
        use self::super::super::root;
        #[doc = " @cond FLATBUFFERS_INTERNAL"]
        pub type uoffset_t = u32;
        pub type voffset_t = u16;
        #[repr(C)]
        pub struct Allocator__bindgen_vtable(cty::c_void);
        #[repr(C)]
        #[derive(Debug, PartialEq, Eq)]
        pub struct Allocator {
            pub vtable_: *const Allocator__bindgen_vtable,
        }
        impl Default for Allocator {
            fn default() -> Self {
                let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
                unsafe {
                    ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
                    s.assume_init()
                }
            }
        }
        #[repr(C)]
        #[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
        pub struct Table {
            pub data_: [u8; 1usize],
        }
        #[repr(C)]
        #[derive(Debug, PartialEq, Eq)]
        pub struct vector_downward<SizeT> {
            pub allocator_: *mut root::flatbuffers::Allocator,
            pub own_allocator_: bool,
            pub initial_size_: usize,
            pub max_size_: SizeT,
            pub buffer_minalign_: usize,
            pub reserved_: usize,
            pub size_: SizeT,
            pub buf_: *mut u8,
            pub cur_: *mut u8,
            pub scratch_: *mut u8,
            pub _phantom_0: ::core::marker::PhantomData<::core::cell::UnsafeCell<SizeT>>,
        }
        impl<SizeT> Default for vector_downward<SizeT> {
            fn default() -> Self {
                let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
                unsafe {
                    ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
                    s.assume_init()
                }
            }
        }
        pub type FlatBufferBuilderImpl_SizeT = u8;
        #[doc = " @cond FLATBUFFERS_INTERNAL"]
        #[repr(C)]
        #[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
        pub struct FlatBufferBuilderImpl_StructKeyComparator {
            pub _address: u8,
        }
        #[doc = " @cond FLATBUFFERS_INTERNAL"]
        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq, Eq)]
        pub struct FlatBufferBuilderImpl_TableKeyComparator {
            pub buf_: *mut root::flatbuffers::vector_downward<
                root::flatbuffers::FlatBufferBuilderImpl_SizeT,
            >,
        }
        impl Default for FlatBufferBuilderImpl_TableKeyComparator {
            fn default() -> Self {
                let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
                unsafe {
                    ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
                    s.assume_init()
                }
            }
        }
        #[repr(C)]
        #[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
        pub struct FlatBufferBuilderImpl_FieldLoc {
            pub off: root::flatbuffers::uoffset_t,
            pub id: root::flatbuffers::voffset_t,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq, Eq)]
        pub struct FlatBufferBuilderImpl_StringOffsetCompare {
            pub buf_: *const root::flatbuffers::vector_downward<
                root::flatbuffers::FlatBufferBuilderImpl_SizeT,
            >,
        }
        impl Default for FlatBufferBuilderImpl_StringOffsetCompare {
            fn default() -> Self {
                let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
                unsafe {
                    ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
                    s.assume_init()
                }
            }
        }
        pub type FlatBufferBuilderImpl_StringOffsetMap = root::std::set;
        #[doc = " @}"]
        pub type FlatBufferBuilder = [u32; 17usize];
        #[repr(C)]
        #[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
        pub struct NativeTable {
            pub _address: u8,
        }
    }
    #[repr(u32)]
    #[doc = " Types supported by tensor"]
    #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
    pub enum TfLiteType {
        kTfLiteNoType = 0,
        kTfLiteFloat32 = 1,
        kTfLiteInt32 = 2,
        kTfLiteUInt8 = 3,
        kTfLiteInt64 = 4,
        kTfLiteString = 5,
        kTfLiteBool = 6,
        kTfLiteInt16 = 7,
        kTfLiteComplex64 = 8,
        kTfLiteInt8 = 9,
        kTfLiteFloat16 = 10,
        kTfLiteFloat64 = 11,
        kTfLiteComplex128 = 12,
        kTfLiteUInt64 = 13,
        kTfLiteResource = 14,
        kTfLiteVariant = 15,
        kTfLiteUInt32 = 16,
        kTfLiteUInt16 = 17,
        kTfLiteInt4 = 18,
    }
    #[doc = " Legacy. Will be deprecated in favor of `TfLiteAffineQuantization`.\n If per-layer quantization is specified this field will still be populated in\n addition to `TfLiteAffineQuantization`.\n Parameters for asymmetric quantization. Quantized values can be converted\n back to float using: `real_value = scale * (quantized_value - zero_point)`"]
    #[repr(C)]
    #[derive(Debug, Default, Copy, Clone, PartialEq)]
    pub struct TfLiteQuantizationParams {
        pub scale: f32,
        pub zero_point: i32,
    }
    #[doc = " Fixed size list of integers. Used for dimensions and inputs/outputs tensor\n indices"]
    #[repr(C)]
    #[derive(Debug, Default)]
    pub struct TfLiteIntArray {
        pub size: cty::c_int,
        pub data: root::__IncompleteArrayField<cty::c_int>,
    }
    #[doc = " Single-precision complex data type compatible with the C99 definition."]
    #[repr(C)]
    #[derive(Debug, Default, Copy, Clone, PartialEq)]
    pub struct TfLiteComplex64 {
        pub re: f32,
        pub im: f32,
    }
    #[doc = " Double-precision complex data type compatible with the C99 definition."]
    #[repr(C)]
    #[derive(Debug, Default, Copy, Clone, PartialEq)]
    pub struct TfLiteComplex128 {
        pub re: f64,
        pub im: f64,
    }
    #[doc = " Half precision data type compatible with the C99 definition."]
    #[repr(C)]
    #[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
    pub struct TfLiteFloat16 {
        pub data: u16,
    }
    #[repr(u32)]
    #[doc = " SupportedQuantizationTypes."]
    #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
    pub enum TfLiteQuantizationType {
        #[doc = " No quantization."]
        kTfLiteNoQuantization = 0,
        #[doc = " Affine quantization (with support for per-channel quantization).\n Corresponds to TfLiteAffineQuantization."]
        kTfLiteAffineQuantization = 1,
    }
    #[doc = " Structure specifying the quantization used by the tensor, if-any."]
    #[repr(C)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq)]
    pub struct TfLiteQuantization {
        #[doc = " The type of quantization held by params."]
        pub type_: root::TfLiteQuantizationType,
        #[doc = " Holds an optional reference to a quantization param structure. The actual\n type depends on the value of the `type` field (see the comment there for\n the values and corresponding types)."]
        pub params: *mut cty::c_void,
    }
    impl Default for TfLiteQuantization {
        fn default() -> Self {
            let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
            unsafe {
                ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
                s.assume_init()
            }
        }
    }
    #[doc = " A union of pointers that points to memory for a given tensor.\n\n Do not access these members directly, if possible, use\n `GetTensorData<TYPE>(tensor)` instead, otherwise only access `.data`, as\n other members are deprecated."]
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub union TfLitePtrUnion {
        pub i32_: *mut i32,
        pub u32_: *mut u32,
        pub i64_: *mut i64,
        pub u64_: *mut u64,
        pub f: *mut f32,
        pub f16: *mut root::TfLiteFloat16,
        pub f64_: *mut f64,
        pub raw: *mut cty::c_char,
        pub raw_const: *const cty::c_char,
        pub uint8: *mut u8,
        pub b: *mut bool,
        pub i16_: *mut i16,
        pub ui16: *mut u16,
        pub c64: *mut root::TfLiteComplex64,
        pub c128: *mut root::TfLiteComplex128,
        pub int8: *mut i8,
        #[doc = " Only use this member."]
        pub data: *mut cty::c_void,
    }
    impl Default for TfLitePtrUnion {
        fn default() -> Self {
            let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
            unsafe {
                ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
                s.assume_init()
            }
        }
    }
    impl ::core::fmt::Debug for TfLitePtrUnion {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
            write!(f, "TfLitePtrUnion {{ union }}")
        }
    }
    #[repr(u32)]
    #[doc = " Memory allocation strategies.\n  * `kTfLiteMmapRo`: Read-only memory-mapped data, or data externally\n        allocated.\n  * `kTfLiteArenaRw`: Arena allocated with no guarantees about persistence,\n        and available during eval.\n  * `kTfLiteArenaRwPersistent`: Arena allocated but persistent across eval,\n  and only available during eval.\n  * `kTfLiteDynamic`: Allocated during eval, or for string tensors.\n  * `kTfLitePersistentRo`: Allocated and populated during prepare. This is\n        useful for tensors that can be computed during prepare and treated\n        as constant inputs for downstream ops (also in prepare).\n  * `kTfLiteCustom`: Custom memory allocation provided by the user. See\n        TfLiteCustomAllocation below.\n  * `kTfLiteVariantObject`: Allocation is an arbitrary type-erased C++\n  object.\n        Allocation and deallocation are done through `new` and `delete`."]
    #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
    pub enum TfLiteAllocationType {
        kTfLiteMemNone = 0,
        kTfLiteMmapRo = 1,
        kTfLiteArenaRw = 2,
        kTfLiteArenaRwPersistent = 3,
        kTfLiteDynamic = 4,
        kTfLitePersistentRo = 5,
        kTfLiteCustom = 6,
        kTfLiteVariantObject = 7,
    }
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub struct TfLiteTensor {
        pub quantization: root::TfLiteQuantization,
        pub params: root::TfLiteQuantizationParams,
        pub data: root::TfLitePtrUnion,
        pub dims: *mut root::TfLiteIntArray,
        pub bytes: usize,
        pub type_: root::TfLiteType,
        pub allocation_type: root::TfLiteAllocationType,
        pub is_variable: bool,
    }
    impl Default for TfLiteTensor {
        fn default() -> Self {
            let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
            unsafe {
                ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
                s.assume_init()
            }
        }
    }
    impl ::core::fmt::Debug for TfLiteTensor {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
            write ! (f , "TfLiteTensor {{ quantization: {:?}, params: {:?}, data: {:?}, dims: {:?}, type: {:?}, allocation_type: {:?}, is_variable: {:?} }}" , self . quantization , self . params , self . data , self . dims , self . type_ , self . allocation_type , self . is_variable)
        }
    }
    pub mod tflite {
        #[allow(unused_imports)]
        use self::super::super::root;
        impl root::tflite::TensorType {
            pub const TensorType_MIN: root::tflite::TensorType = TensorType::TensorType_FLOAT32;
        }
        impl root::tflite::TensorType {
            pub const TensorType_MAX: root::tflite::TensorType = TensorType::TensorType_INT4;
        }
        #[repr(i8)]
        #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
        pub enum TensorType {
            TensorType_FLOAT32 = 0,
            TensorType_FLOAT16 = 1,
            TensorType_INT32 = 2,
            TensorType_UINT8 = 3,
            TensorType_INT64 = 4,
            TensorType_STRING = 5,
            TensorType_BOOL = 6,
            TensorType_INT16 = 7,
            TensorType_COMPLEX64 = 8,
            TensorType_INT8 = 9,
            TensorType_FLOAT64 = 10,
            TensorType_COMPLEX128 = 11,
            TensorType_UINT64 = 12,
            TensorType_RESOURCE = 13,
            TensorType_VARIANT = 14,
            TensorType_UINT32 = 15,
            TensorType_UINT16 = 16,
            TensorType_INT4 = 17,
        }
        impl root::tflite::QuantizationDetails {
            pub const QuantizationDetails_MIN: root::tflite::QuantizationDetails =
                QuantizationDetails::QuantizationDetails_NONE;
        }
        impl root::tflite::QuantizationDetails {
            pub const QuantizationDetails_MAX: root::tflite::QuantizationDetails =
                QuantizationDetails::QuantizationDetails_CustomQuantization;
        }
        #[repr(u8)]
        #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
        pub enum QuantizationDetails {
            QuantizationDetails_NONE = 0,
            QuantizationDetails_CustomQuantization = 1,
        }
        #[repr(C)]
        #[derive(Debug, PartialEq, Eq)]
        pub struct QuantizationDetailsUnion {
            pub type_: root::tflite::QuantizationDetails,
            pub value: *mut cty::c_void,
        }
        impl Default for QuantizationDetailsUnion {
            fn default() -> Self {
                let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
                unsafe {
                    ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
                    s.assume_init()
                }
            }
        }
        impl root::tflite::DimensionType {
            pub const DimensionType_MIN: root::tflite::DimensionType =
                DimensionType::DimensionType_DENSE;
        }
        impl root::tflite::DimensionType {
            pub const DimensionType_MAX: root::tflite::DimensionType =
                DimensionType::DimensionType_SPARSE_CSR;
        }
        #[repr(i8)]
        #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
        pub enum DimensionType {
            DimensionType_DENSE = 0,
            DimensionType_SPARSE_CSR = 1,
        }
        impl root::tflite::SparseIndexVector {
            pub const SparseIndexVector_MIN: root::tflite::SparseIndexVector =
                SparseIndexVector::SparseIndexVector_NONE;
        }
        impl root::tflite::SparseIndexVector {
            pub const SparseIndexVector_MAX: root::tflite::SparseIndexVector =
                SparseIndexVector::SparseIndexVector_Uint8Vector;
        }
        #[repr(u8)]
        #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
        pub enum SparseIndexVector {
            SparseIndexVector_NONE = 0,
            SparseIndexVector_Int32Vector = 1,
            SparseIndexVector_Uint16Vector = 2,
            SparseIndexVector_Uint8Vector = 3,
        }
        #[repr(C)]
        #[derive(Debug, PartialEq, Eq)]
        pub struct SparseIndexVectorUnion {
            pub type_: root::tflite::SparseIndexVector,
            pub value: *mut cty::c_void,
        }
        impl Default for SparseIndexVectorUnion {
            fn default() -> Self {
                let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
                unsafe {
                    ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
                    s.assume_init()
                }
            }
        }
        impl root::tflite::BuiltinOperator {
            pub const BuiltinOperator_MIN: root::tflite::BuiltinOperator =
                BuiltinOperator::BuiltinOperator_ADD;
        }
        impl root::tflite::BuiltinOperator {
            pub const BuiltinOperator_MAX: root::tflite::BuiltinOperator =
                BuiltinOperator::BuiltinOperator_REDUCE_WINDOW;
        }
        #[repr(i32)]
        #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
        pub enum BuiltinOperator {
            BuiltinOperator_ADD = 0,
            BuiltinOperator_AVERAGE_POOL_2D = 1,
            BuiltinOperator_CONCATENATION = 2,
            BuiltinOperator_CONV_2D = 3,
            BuiltinOperator_DEPTHWISE_CONV_2D = 4,
            BuiltinOperator_DEPTH_TO_SPACE = 5,
            BuiltinOperator_DEQUANTIZE = 6,
            BuiltinOperator_EMBEDDING_LOOKUP = 7,
            BuiltinOperator_FLOOR = 8,
            BuiltinOperator_FULLY_CONNECTED = 9,
            BuiltinOperator_HASHTABLE_LOOKUP = 10,
            BuiltinOperator_L2_NORMALIZATION = 11,
            BuiltinOperator_L2_POOL_2D = 12,
            BuiltinOperator_LOCAL_RESPONSE_NORMALIZATION = 13,
            BuiltinOperator_LOGISTIC = 14,
            BuiltinOperator_LSH_PROJECTION = 15,
            BuiltinOperator_LSTM = 16,
            BuiltinOperator_MAX_POOL_2D = 17,
            BuiltinOperator_MUL = 18,
            BuiltinOperator_RELU = 19,
            BuiltinOperator_RELU_N1_TO_1 = 20,
            BuiltinOperator_RELU6 = 21,
            BuiltinOperator_RESHAPE = 22,
            BuiltinOperator_RESIZE_BILINEAR = 23,
            BuiltinOperator_RNN = 24,
            BuiltinOperator_SOFTMAX = 25,
            BuiltinOperator_SPACE_TO_DEPTH = 26,
            BuiltinOperator_SVDF = 27,
            BuiltinOperator_TANH = 28,
            BuiltinOperator_CONCAT_EMBEDDINGS = 29,
            BuiltinOperator_SKIP_GRAM = 30,
            BuiltinOperator_CALL = 31,
            BuiltinOperator_CUSTOM = 32,
            BuiltinOperator_EMBEDDING_LOOKUP_SPARSE = 33,
            BuiltinOperator_PAD = 34,
            BuiltinOperator_UNIDIRECTIONAL_SEQUENCE_RNN = 35,
            BuiltinOperator_GATHER = 36,
            BuiltinOperator_BATCH_TO_SPACE_ND = 37,
            BuiltinOperator_SPACE_TO_BATCH_ND = 38,
            BuiltinOperator_TRANSPOSE = 39,
            BuiltinOperator_MEAN = 40,
            BuiltinOperator_SUB = 41,
            BuiltinOperator_DIV = 42,
            BuiltinOperator_SQUEEZE = 43,
            BuiltinOperator_UNIDIRECTIONAL_SEQUENCE_LSTM = 44,
            BuiltinOperator_STRIDED_SLICE = 45,
            BuiltinOperator_BIDIRECTIONAL_SEQUENCE_RNN = 46,
            BuiltinOperator_EXP = 47,
            BuiltinOperator_TOPK_V2 = 48,
            BuiltinOperator_SPLIT = 49,
            BuiltinOperator_LOG_SOFTMAX = 50,
            BuiltinOperator_DELEGATE = 51,
            BuiltinOperator_BIDIRECTIONAL_SEQUENCE_LSTM = 52,
            BuiltinOperator_CAST = 53,
            BuiltinOperator_PRELU = 54,
            BuiltinOperator_MAXIMUM = 55,
            BuiltinOperator_ARG_MAX = 56,
            BuiltinOperator_MINIMUM = 57,
            BuiltinOperator_LESS = 58,
            BuiltinOperator_NEG = 59,
            BuiltinOperator_PADV2 = 60,
            BuiltinOperator_GREATER = 61,
            BuiltinOperator_GREATER_EQUAL = 62,
            BuiltinOperator_LESS_EQUAL = 63,
            BuiltinOperator_SELECT = 64,
            BuiltinOperator_SLICE = 65,
            BuiltinOperator_SIN = 66,
            BuiltinOperator_TRANSPOSE_CONV = 67,
            BuiltinOperator_SPARSE_TO_DENSE = 68,
            BuiltinOperator_TILE = 69,
            BuiltinOperator_EXPAND_DIMS = 70,
            BuiltinOperator_EQUAL = 71,
            BuiltinOperator_NOT_EQUAL = 72,
            BuiltinOperator_LOG = 73,
            BuiltinOperator_SUM = 74,
            BuiltinOperator_SQRT = 75,
            BuiltinOperator_RSQRT = 76,
            BuiltinOperator_SHAPE = 77,
            BuiltinOperator_POW = 78,
            BuiltinOperator_ARG_MIN = 79,
            BuiltinOperator_FAKE_QUANT = 80,
            BuiltinOperator_REDUCE_PROD = 81,
            BuiltinOperator_REDUCE_MAX = 82,
            BuiltinOperator_PACK = 83,
            BuiltinOperator_LOGICAL_OR = 84,
            BuiltinOperator_ONE_HOT = 85,
            BuiltinOperator_LOGICAL_AND = 86,
            BuiltinOperator_LOGICAL_NOT = 87,
            BuiltinOperator_UNPACK = 88,
            BuiltinOperator_REDUCE_MIN = 89,
            BuiltinOperator_FLOOR_DIV = 90,
            BuiltinOperator_REDUCE_ANY = 91,
            BuiltinOperator_SQUARE = 92,
            BuiltinOperator_ZEROS_LIKE = 93,
            BuiltinOperator_FILL = 94,
            BuiltinOperator_FLOOR_MOD = 95,
            BuiltinOperator_RANGE = 96,
            BuiltinOperator_RESIZE_NEAREST_NEIGHBOR = 97,
            BuiltinOperator_LEAKY_RELU = 98,
            BuiltinOperator_SQUARED_DIFFERENCE = 99,
            BuiltinOperator_MIRROR_PAD = 100,
            BuiltinOperator_ABS = 101,
            BuiltinOperator_SPLIT_V = 102,
            BuiltinOperator_UNIQUE = 103,
            BuiltinOperator_CEIL = 104,
            BuiltinOperator_REVERSE_V2 = 105,
            BuiltinOperator_ADD_N = 106,
            BuiltinOperator_GATHER_ND = 107,
            BuiltinOperator_COS = 108,
            BuiltinOperator_WHERE = 109,
            BuiltinOperator_RANK = 110,
            BuiltinOperator_ELU = 111,
            BuiltinOperator_REVERSE_SEQUENCE = 112,
            BuiltinOperator_MATRIX_DIAG = 113,
            BuiltinOperator_QUANTIZE = 114,
            BuiltinOperator_MATRIX_SET_DIAG = 115,
            BuiltinOperator_ROUND = 116,
            BuiltinOperator_HARD_SWISH = 117,
            BuiltinOperator_IF = 118,
            BuiltinOperator_WHILE = 119,
            BuiltinOperator_NON_MAX_SUPPRESSION_V4 = 120,
            BuiltinOperator_NON_MAX_SUPPRESSION_V5 = 121,
            BuiltinOperator_SCATTER_ND = 122,
            BuiltinOperator_SELECT_V2 = 123,
            BuiltinOperator_DENSIFY = 124,
            BuiltinOperator_SEGMENT_SUM = 125,
            BuiltinOperator_BATCH_MATMUL = 126,
            BuiltinOperator_PLACEHOLDER_FOR_GREATER_OP_CODES = 127,
            BuiltinOperator_CUMSUM = 128,
            BuiltinOperator_CALL_ONCE = 129,
            BuiltinOperator_BROADCAST_TO = 130,
            BuiltinOperator_RFFT2D = 131,
            BuiltinOperator_CONV_3D = 132,
            BuiltinOperator_IMAG = 133,
            BuiltinOperator_REAL = 134,
            BuiltinOperator_COMPLEX_ABS = 135,
            BuiltinOperator_HASHTABLE = 136,
            BuiltinOperator_HASHTABLE_FIND = 137,
            BuiltinOperator_HASHTABLE_IMPORT = 138,
            BuiltinOperator_HASHTABLE_SIZE = 139,
            BuiltinOperator_REDUCE_ALL = 140,
            BuiltinOperator_CONV_3D_TRANSPOSE = 141,
            BuiltinOperator_VAR_HANDLE = 142,
            BuiltinOperator_READ_VARIABLE = 143,
            BuiltinOperator_ASSIGN_VARIABLE = 144,
            BuiltinOperator_BROADCAST_ARGS = 145,
            BuiltinOperator_RANDOM_STANDARD_NORMAL = 146,
            BuiltinOperator_BUCKETIZE = 147,
            BuiltinOperator_RANDOM_UNIFORM = 148,
            BuiltinOperator_MULTINOMIAL = 149,
            BuiltinOperator_GELU = 150,
            BuiltinOperator_DYNAMIC_UPDATE_SLICE = 151,
            BuiltinOperator_RELU_0_TO_1 = 152,
            BuiltinOperator_UNSORTED_SEGMENT_PROD = 153,
            BuiltinOperator_UNSORTED_SEGMENT_MAX = 154,
            BuiltinOperator_UNSORTED_SEGMENT_SUM = 155,
            BuiltinOperator_ATAN2 = 156,
            BuiltinOperator_UNSORTED_SEGMENT_MIN = 157,
            BuiltinOperator_SIGN = 158,
            BuiltinOperator_BITCAST = 159,
            BuiltinOperator_BITWISE_XOR = 160,
            BuiltinOperator_RIGHT_SHIFT = 161,
            BuiltinOperator_STABLEHLO_LOGISTIC = 162,
            BuiltinOperator_STABLEHLO_ADD = 163,
            BuiltinOperator_STABLEHLO_DIVIDE = 164,
            BuiltinOperator_STABLEHLO_MULTIPLY = 165,
            BuiltinOperator_STABLEHLO_MAXIMUM = 166,
            BuiltinOperator_STABLEHLO_RESHAPE = 167,
            BuiltinOperator_STABLEHLO_CLAMP = 168,
            BuiltinOperator_STABLEHLO_CONCATENATE = 169,
            BuiltinOperator_STABLEHLO_BROADCAST_IN_DIM = 170,
            BuiltinOperator_STABLEHLO_CONVOLUTION = 171,
            BuiltinOperator_STABLEHLO_SLICE = 172,
            BuiltinOperator_STABLEHLO_CUSTOM_CALL = 173,
            BuiltinOperator_STABLEHLO_REDUCE = 174,
            BuiltinOperator_STABLEHLO_ABS = 175,
            BuiltinOperator_STABLEHLO_AND = 176,
            BuiltinOperator_STABLEHLO_COSINE = 177,
            BuiltinOperator_STABLEHLO_EXPONENTIAL = 178,
            BuiltinOperator_STABLEHLO_FLOOR = 179,
            BuiltinOperator_STABLEHLO_LOG = 180,
            BuiltinOperator_STABLEHLO_MINIMUM = 181,
            BuiltinOperator_STABLEHLO_NEGATE = 182,
            BuiltinOperator_STABLEHLO_OR = 183,
            BuiltinOperator_STABLEHLO_POWER = 184,
            BuiltinOperator_STABLEHLO_REMAINDER = 185,
            BuiltinOperator_STABLEHLO_RSQRT = 186,
            BuiltinOperator_STABLEHLO_SELECT = 187,
            BuiltinOperator_STABLEHLO_SUBTRACT = 188,
            BuiltinOperator_STABLEHLO_TANH = 189,
            BuiltinOperator_STABLEHLO_SCATTER = 190,
            BuiltinOperator_STABLEHLO_COMPARE = 191,
            BuiltinOperator_STABLEHLO_CONVERT = 192,
            BuiltinOperator_STABLEHLO_DYNAMIC_SLICE = 193,
            BuiltinOperator_STABLEHLO_DYNAMIC_UPDATE_SLICE = 194,
            BuiltinOperator_STABLEHLO_PAD = 195,
            BuiltinOperator_STABLEHLO_IOTA = 196,
            BuiltinOperator_STABLEHLO_DOT_GENERAL = 197,
            BuiltinOperator_STABLEHLO_REDUCE_WINDOW = 198,
            BuiltinOperator_STABLEHLO_SORT = 199,
            BuiltinOperator_STABLEHLO_WHILE = 200,
            BuiltinOperator_STABLEHLO_GATHER = 201,
            BuiltinOperator_STABLEHLO_TRANSPOSE = 202,
            BuiltinOperator_DILATE = 203,
            BuiltinOperator_STABLEHLO_RNG_BIT_GENERATOR = 204,
            BuiltinOperator_REDUCE_WINDOW = 205,
        }
        impl root::tflite::BuiltinOptions {
            pub const BuiltinOptions_MIN: root::tflite::BuiltinOptions =
                BuiltinOptions::BuiltinOptions_NONE;
        }
        impl root::tflite::BuiltinOptions {
            pub const BuiltinOptions_MAX: root::tflite::BuiltinOptions =
                BuiltinOptions::BuiltinOptions_RightShiftOptions;
        }
        #[repr(u8)]
        #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
        pub enum BuiltinOptions {
            BuiltinOptions_NONE = 0,
            BuiltinOptions_Conv2DOptions = 1,
            BuiltinOptions_DepthwiseConv2DOptions = 2,
            BuiltinOptions_ConcatEmbeddingsOptions = 3,
            BuiltinOptions_LSHProjectionOptions = 4,
            BuiltinOptions_Pool2DOptions = 5,
            BuiltinOptions_SVDFOptions = 6,
            BuiltinOptions_RNNOptions = 7,
            BuiltinOptions_FullyConnectedOptions = 8,
            BuiltinOptions_SoftmaxOptions = 9,
            BuiltinOptions_ConcatenationOptions = 10,
            BuiltinOptions_AddOptions = 11,
            BuiltinOptions_L2NormOptions = 12,
            BuiltinOptions_LocalResponseNormalizationOptions = 13,
            BuiltinOptions_LSTMOptions = 14,
            BuiltinOptions_ResizeBilinearOptions = 15,
            BuiltinOptions_CallOptions = 16,
            BuiltinOptions_ReshapeOptions = 17,
            BuiltinOptions_SkipGramOptions = 18,
            BuiltinOptions_SpaceToDepthOptions = 19,
            BuiltinOptions_EmbeddingLookupSparseOptions = 20,
            BuiltinOptions_MulOptions = 21,
            BuiltinOptions_PadOptions = 22,
            BuiltinOptions_GatherOptions = 23,
            BuiltinOptions_BatchToSpaceNDOptions = 24,
            BuiltinOptions_SpaceToBatchNDOptions = 25,
            BuiltinOptions_TransposeOptions = 26,
            BuiltinOptions_ReducerOptions = 27,
            BuiltinOptions_SubOptions = 28,
            BuiltinOptions_DivOptions = 29,
            BuiltinOptions_SqueezeOptions = 30,
            BuiltinOptions_SequenceRNNOptions = 31,
            BuiltinOptions_StridedSliceOptions = 32,
            BuiltinOptions_ExpOptions = 33,
            BuiltinOptions_TopKV2Options = 34,
            BuiltinOptions_SplitOptions = 35,
            BuiltinOptions_LogSoftmaxOptions = 36,
            BuiltinOptions_CastOptions = 37,
            BuiltinOptions_DequantizeOptions = 38,
            BuiltinOptions_MaximumMinimumOptions = 39,
            BuiltinOptions_ArgMaxOptions = 40,
            BuiltinOptions_LessOptions = 41,
            BuiltinOptions_NegOptions = 42,
            BuiltinOptions_PadV2Options = 43,
            BuiltinOptions_GreaterOptions = 44,
            BuiltinOptions_GreaterEqualOptions = 45,
            BuiltinOptions_LessEqualOptions = 46,
            BuiltinOptions_SelectOptions = 47,
            BuiltinOptions_SliceOptions = 48,
            BuiltinOptions_TransposeConvOptions = 49,
            BuiltinOptions_SparseToDenseOptions = 50,
            BuiltinOptions_TileOptions = 51,
            BuiltinOptions_ExpandDimsOptions = 52,
            BuiltinOptions_EqualOptions = 53,
            BuiltinOptions_NotEqualOptions = 54,
            BuiltinOptions_ShapeOptions = 55,
            BuiltinOptions_PowOptions = 56,
            BuiltinOptions_ArgMinOptions = 57,
            BuiltinOptions_FakeQuantOptions = 58,
            BuiltinOptions_PackOptions = 59,
            BuiltinOptions_LogicalOrOptions = 60,
            BuiltinOptions_OneHotOptions = 61,
            BuiltinOptions_LogicalAndOptions = 62,
            BuiltinOptions_LogicalNotOptions = 63,
            BuiltinOptions_UnpackOptions = 64,
            BuiltinOptions_FloorDivOptions = 65,
            BuiltinOptions_SquareOptions = 66,
            BuiltinOptions_ZerosLikeOptions = 67,
            BuiltinOptions_FillOptions = 68,
            BuiltinOptions_BidirectionalSequenceLSTMOptions = 69,
            BuiltinOptions_BidirectionalSequenceRNNOptions = 70,
            BuiltinOptions_UnidirectionalSequenceLSTMOptions = 71,
            BuiltinOptions_FloorModOptions = 72,
            BuiltinOptions_RangeOptions = 73,
            BuiltinOptions_ResizeNearestNeighborOptions = 74,
            BuiltinOptions_LeakyReluOptions = 75,
            BuiltinOptions_SquaredDifferenceOptions = 76,
            BuiltinOptions_MirrorPadOptions = 77,
            BuiltinOptions_AbsOptions = 78,
            BuiltinOptions_SplitVOptions = 79,
            BuiltinOptions_UniqueOptions = 80,
            BuiltinOptions_ReverseV2Options = 81,
            BuiltinOptions_AddNOptions = 82,
            BuiltinOptions_GatherNdOptions = 83,
            BuiltinOptions_CosOptions = 84,
            BuiltinOptions_WhereOptions = 85,
            BuiltinOptions_RankOptions = 86,
            BuiltinOptions_ReverseSequenceOptions = 87,
            BuiltinOptions_MatrixDiagOptions = 88,
            BuiltinOptions_QuantizeOptions = 89,
            BuiltinOptions_MatrixSetDiagOptions = 90,
            BuiltinOptions_HardSwishOptions = 91,
            BuiltinOptions_IfOptions = 92,
            BuiltinOptions_WhileOptions = 93,
            BuiltinOptions_DepthToSpaceOptions = 94,
            BuiltinOptions_NonMaxSuppressionV4Options = 95,
            BuiltinOptions_NonMaxSuppressionV5Options = 96,
            BuiltinOptions_ScatterNdOptions = 97,
            BuiltinOptions_SelectV2Options = 98,
            BuiltinOptions_DensifyOptions = 99,
            BuiltinOptions_SegmentSumOptions = 100,
            BuiltinOptions_BatchMatMulOptions = 101,
            BuiltinOptions_CumsumOptions = 102,
            BuiltinOptions_CallOnceOptions = 103,
            BuiltinOptions_BroadcastToOptions = 104,
            BuiltinOptions_Rfft2dOptions = 105,
            BuiltinOptions_Conv3DOptions = 106,
            BuiltinOptions_HashtableOptions = 107,
            BuiltinOptions_HashtableFindOptions = 108,
            BuiltinOptions_HashtableImportOptions = 109,
            BuiltinOptions_HashtableSizeOptions = 110,
            BuiltinOptions_VarHandleOptions = 111,
            BuiltinOptions_ReadVariableOptions = 112,
            BuiltinOptions_AssignVariableOptions = 113,
            BuiltinOptions_RandomOptions = 114,
            BuiltinOptions_BucketizeOptions = 115,
            BuiltinOptions_GeluOptions = 116,
            BuiltinOptions_DynamicUpdateSliceOptions = 117,
            BuiltinOptions_UnsortedSegmentProdOptions = 118,
            BuiltinOptions_UnsortedSegmentMaxOptions = 119,
            BuiltinOptions_UnsortedSegmentMinOptions = 120,
            BuiltinOptions_UnsortedSegmentSumOptions = 121,
            BuiltinOptions_ATan2Options = 122,
            BuiltinOptions_SignOptions = 123,
            BuiltinOptions_BitcastOptions = 124,
            BuiltinOptions_BitwiseXorOptions = 125,
            BuiltinOptions_RightShiftOptions = 126,
        }
        #[repr(C)]
        #[derive(Debug, PartialEq, Eq)]
        pub struct BuiltinOptionsUnion {
            pub type_: root::tflite::BuiltinOptions,
            pub value: *mut cty::c_void,
        }
        impl Default for BuiltinOptionsUnion {
            fn default() -> Self {
                let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
                unsafe {
                    ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
                    s.assume_init()
                }
            }
        }
        impl root::tflite::BuiltinOptions2 {
            pub const BuiltinOptions2_MIN: root::tflite::BuiltinOptions2 =
                BuiltinOptions2::BuiltinOptions2_NONE;
        }
        impl root::tflite::BuiltinOptions2 {
            pub const BuiltinOptions2_MAX: root::tflite::BuiltinOptions2 =
                BuiltinOptions2::BuiltinOptions2_ReduceWindowOptions;
        }
        #[repr(u8)]
        #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
        pub enum BuiltinOptions2 {
            BuiltinOptions2_NONE = 0,
            BuiltinOptions2_StablehloConcatenateOptions = 1,
            BuiltinOptions2_StablehloBroadcastInDimOptions = 2,
            BuiltinOptions2_StablehloSliceOptions = 3,
            BuiltinOptions2_StablehloConvolutionOptions = 4,
            BuiltinOptions2_StablehloCustomCallOptions = 5,
            BuiltinOptions2_StablehloReduceOptions = 6,
            BuiltinOptions2_StablehloScatterOptions = 7,
            BuiltinOptions2_StablehloCompareOptions = 8,
            BuiltinOptions2_StablehloDynamicSliceOptions = 9,
            BuiltinOptions2_StablehloPadOptions = 10,
            BuiltinOptions2_StablehloIotaOptions = 11,
            BuiltinOptions2_StablehloDotGeneralOptions = 12,
            BuiltinOptions2_StablehloReduceWindowOptions = 13,
            BuiltinOptions2_StablehloSortOptions = 14,
            BuiltinOptions2_StablehloWhileOptions = 15,
            BuiltinOptions2_StablehloGatherOptions = 16,
            BuiltinOptions2_StablehloTransposeOptions = 17,
            BuiltinOptions2_DilateOptions = 18,
            BuiltinOptions2_StablehloRngBitGeneratorOptions = 19,
            BuiltinOptions2_ReduceWindowOptions = 20,
        }
        #[repr(C)]
        #[derive(Debug, PartialEq, Eq)]
        pub struct BuiltinOptions2Union {
            pub type_: root::tflite::BuiltinOptions2,
            pub value: *mut cty::c_void,
        }
        impl Default for BuiltinOptions2Union {
            fn default() -> Self {
                let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
                unsafe {
                    ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
                    s.assume_init()
                }
            }
        }
        impl root::tflite::CustomOptionsFormat {
            pub const CustomOptionsFormat_MIN: root::tflite::CustomOptionsFormat =
                CustomOptionsFormat::CustomOptionsFormat_FLEXBUFFERS;
        }
        impl root::tflite::CustomOptionsFormat {
            pub const CustomOptionsFormat_MAX: root::tflite::CustomOptionsFormat =
                CustomOptionsFormat::CustomOptionsFormat_FLEXBUFFERS;
        }
        #[repr(i8)]
        #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
        pub enum CustomOptionsFormat {
            CustomOptionsFormat_FLEXBUFFERS = 0,
        }
        #[repr(C)]
        pub struct QuantizationParametersT {
            pub min: root::std::vector,
            pub max: root::std::vector,
            pub scale: root::std::vector,
            pub zero_point: root::std::vector,
            pub details: root::tflite::QuantizationDetailsUnion,
            pub quantized_dimension: i32,
        }
        pub type QuantizationParametersT_TableType = root::tflite::QuantizationParameters;
        impl Default for QuantizationParametersT {
            fn default() -> Self {
                let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
                unsafe {
                    ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
                    s.assume_init()
                }
            }
        }
        impl ::core::fmt::Debug for QuantizationParametersT {
            fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                write ! (f , "QuantizationParametersT {{ min: {:?}, max: {:?}, scale: {:?}, zero_point: {:?}, details: {:?} }}" , self . min , self . max , self . scale , self . zero_point , self . details)
            }
        }
        #[repr(C)]
        #[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
        pub struct QuantizationParameters {
            pub _base: root::flatbuffers::Table,
        }
        pub type QuantizationParameters_NativeTableType = root::tflite::QuantizationParametersT;
        pub type QuantizationParameters_Builder = root::tflite::QuantizationParametersBuilder;
        #[repr(u16)]
        #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
        pub enum QuantizationParameters_FlatBuffersVTableOffset {
            VT_MIN = 4,
            VT_MAX = 6,
            VT_SCALE = 8,
            VT_ZERO_POINT = 10,
            VT_DETAILS_TYPE = 12,
            VT_DETAILS = 14,
            VT_QUANTIZED_DIMENSION = 16,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq, Eq)]
        pub struct QuantizationParametersBuilder {
            pub fbb_: *mut root::flatbuffers::FlatBufferBuilder,
            pub start_: root::flatbuffers::uoffset_t,
        }
        pub type QuantizationParametersBuilder_Table = root::tflite::QuantizationParameters;
        impl Default for QuantizationParametersBuilder {
            fn default() -> Self {
                let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
                unsafe {
                    ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
                    s.assume_init()
                }
            }
        }
        #[repr(C)]
        #[derive(Debug, PartialEq, Eq)]
        pub struct DimensionMetadataT {
            pub format: root::tflite::DimensionType,
            pub dense_size: i32,
            pub array_segments: root::tflite::SparseIndexVectorUnion,
            pub array_indices: root::tflite::SparseIndexVectorUnion,
        }
        pub type DimensionMetadataT_TableType = root::tflite::DimensionMetadata;
        impl Default for DimensionMetadataT {
            fn default() -> Self {
                let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
                unsafe {
                    ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
                    s.assume_init()
                }
            }
        }
        #[repr(C)]
        #[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
        pub struct DimensionMetadata {
            pub _base: root::flatbuffers::Table,
        }
        pub type DimensionMetadata_NativeTableType = root::tflite::DimensionMetadataT;
        pub type DimensionMetadata_Builder = root::tflite::DimensionMetadataBuilder;
        #[repr(u16)]
        #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
        pub enum DimensionMetadata_FlatBuffersVTableOffset {
            VT_FORMAT = 4,
            VT_DENSE_SIZE = 6,
            VT_ARRAY_SEGMENTS_TYPE = 8,
            VT_ARRAY_SEGMENTS = 10,
            VT_ARRAY_INDICES_TYPE = 12,
            VT_ARRAY_INDICES = 14,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq, Eq)]
        pub struct DimensionMetadataBuilder {
            pub fbb_: *mut root::flatbuffers::FlatBufferBuilder,
            pub start_: root::flatbuffers::uoffset_t,
        }
        pub type DimensionMetadataBuilder_Table = root::tflite::DimensionMetadata;
        impl Default for DimensionMetadataBuilder {
            fn default() -> Self {
                let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
                unsafe {
                    ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
                    s.assume_init()
                }
            }
        }
        #[repr(C)]
        pub struct SparsityParametersT {
            pub traversal_order: root::std::vector,
            pub block_map: root::std::vector,
            pub dim_metadata: root::std::vector,
        }
        pub type SparsityParametersT_TableType = root::tflite::SparsityParameters;
        impl Default for SparsityParametersT {
            fn default() -> Self {
                let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
                unsafe {
                    ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
                    s.assume_init()
                }
            }
        }
        impl ::core::fmt::Debug for SparsityParametersT {
            fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                write ! (f , "SparsityParametersT {{ traversal_order: {:?}, block_map: {:?}, dim_metadata: {:?} }}" , self . traversal_order , self . block_map , self . dim_metadata)
            }
        }
        #[repr(C)]
        #[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
        pub struct SparsityParameters {
            pub _base: root::flatbuffers::Table,
        }
        pub type SparsityParameters_NativeTableType = root::tflite::SparsityParametersT;
        pub type SparsityParameters_Builder = root::tflite::SparsityParametersBuilder;
        #[repr(u16)]
        #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
        pub enum SparsityParameters_FlatBuffersVTableOffset {
            VT_TRAVERSAL_ORDER = 4,
            VT_BLOCK_MAP = 6,
            VT_DIM_METADATA = 8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq, Eq)]
        pub struct SparsityParametersBuilder {
            pub fbb_: *mut root::flatbuffers::FlatBufferBuilder,
            pub start_: root::flatbuffers::uoffset_t,
        }
        pub type SparsityParametersBuilder_Table = root::tflite::SparsityParameters;
        impl Default for SparsityParametersBuilder {
            fn default() -> Self {
                let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
                unsafe {
                    ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
                    s.assume_init()
                }
            }
        }
        #[repr(C)]
        pub struct VariantSubTypeT {
            pub shape: root::std::vector,
            pub type_: root::tflite::TensorType,
            pub has_rank: bool,
        }
        pub type VariantSubTypeT_TableType = root::tflite::VariantSubType;
        impl Default for VariantSubTypeT {
            fn default() -> Self {
                let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
                unsafe {
                    ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
                    s.assume_init()
                }
            }
        }
        impl ::core::fmt::Debug for VariantSubTypeT {
            fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                write!(
                    f,
                    "VariantSubTypeT {{ shape: {:?}, type: {:?}, has_rank: {:?} }}",
                    self.shape, self.type_, self.has_rank
                )
            }
        }
        #[repr(C)]
        #[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
        pub struct VariantSubType {
            pub _base: root::flatbuffers::Table,
        }
        pub type VariantSubType_NativeTableType = root::tflite::VariantSubTypeT;
        pub type VariantSubType_Builder = root::tflite::VariantSubTypeBuilder;
        #[repr(u16)]
        #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
        pub enum VariantSubType_FlatBuffersVTableOffset {
            VT_SHAPE = 4,
            VT_TYPE = 6,
            VT_HAS_RANK = 8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq, Eq)]
        pub struct VariantSubTypeBuilder {
            pub fbb_: *mut root::flatbuffers::FlatBufferBuilder,
            pub start_: root::flatbuffers::uoffset_t,
        }
        pub type VariantSubTypeBuilder_Table = root::tflite::VariantSubType;
        impl Default for VariantSubTypeBuilder {
            fn default() -> Self {
                let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
                unsafe {
                    ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
                    s.assume_init()
                }
            }
        }
        #[repr(C)]
        pub struct TensorT {
            pub shape: root::std::vector,
            pub type_: root::tflite::TensorType,
            pub buffer: u32,
            pub name: root::std::string,
            pub quantization: root::std::unique_ptr,
            pub is_variable: bool,
            pub sparsity: root::std::unique_ptr,
            pub shape_signature: root::std::vector,
            pub has_rank: bool,
            pub variant_tensors: root::std::vector,
        }
        pub type TensorT_TableType = root::tflite::Tensor;
        impl Default for TensorT {
            fn default() -> Self {
                let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
                unsafe {
                    ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
                    s.assume_init()
                }
            }
        }
        impl ::core::fmt::Debug for TensorT {
            fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                write ! (f , "TensorT {{ shape: {:?}, type: {:?}, name: {:?}, quantization: {:?}, is_variable: {:?}, sparsity: {:?}, shape_signature: {:?}, has_rank: {:?}, variant_tensors: {:?} }}" , self . shape , self . type_ , self . name , self . quantization , self . is_variable , self . sparsity , self . shape_signature , self . has_rank , self . variant_tensors)
            }
        }
        #[repr(C)]
        #[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
        pub struct Tensor {
            pub _base: root::flatbuffers::Table,
        }
        pub type Tensor_NativeTableType = root::tflite::TensorT;
        pub type Tensor_Builder = root::tflite::TensorBuilder;
        #[repr(u16)]
        #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
        pub enum Tensor_FlatBuffersVTableOffset {
            VT_SHAPE = 4,
            VT_TYPE = 6,
            VT_BUFFER = 8,
            VT_NAME = 10,
            VT_QUANTIZATION = 12,
            VT_IS_VARIABLE = 14,
            VT_SPARSITY = 16,
            VT_SHAPE_SIGNATURE = 18,
            VT_HAS_RANK = 20,
            VT_VARIANT_TENSORS = 22,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq, Eq)]
        pub struct TensorBuilder {
            pub fbb_: *mut root::flatbuffers::FlatBufferBuilder,
            pub start_: root::flatbuffers::uoffset_t,
        }
        pub type TensorBuilder_Table = root::tflite::Tensor;
        impl Default for TensorBuilder {
            fn default() -> Self {
                let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
                unsafe {
                    ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
                    s.assume_init()
                }
            }
        }
        #[repr(C)]
        pub struct OperatorCodeT {
            pub deprecated_builtin_code: i8,
            pub custom_code: root::std::string,
            pub version: i32,
            pub builtin_code: root::tflite::BuiltinOperator,
        }
        pub type OperatorCodeT_TableType = root::tflite::OperatorCode;
        impl Default for OperatorCodeT {
            fn default() -> Self {
                let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
                unsafe {
                    ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
                    s.assume_init()
                }
            }
        }
        impl ::core::fmt::Debug for OperatorCodeT {
            fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                write!(
                    f,
                    "OperatorCodeT {{ custom_code: {:?}, builtin_code: {:?} }}",
                    self.custom_code, self.builtin_code
                )
            }
        }
        #[repr(C)]
        #[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
        pub struct OperatorCode {
            pub _base: root::flatbuffers::Table,
        }
        pub type OperatorCode_NativeTableType = root::tflite::OperatorCodeT;
        pub type OperatorCode_Builder = root::tflite::OperatorCodeBuilder;
        #[repr(u16)]
        #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
        pub enum OperatorCode_FlatBuffersVTableOffset {
            VT_DEPRECATED_BUILTIN_CODE = 4,
            VT_CUSTOM_CODE = 6,
            VT_VERSION = 8,
            VT_BUILTIN_CODE = 10,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq, Eq)]
        pub struct OperatorCodeBuilder {
            pub fbb_: *mut root::flatbuffers::FlatBufferBuilder,
            pub start_: root::flatbuffers::uoffset_t,
        }
        pub type OperatorCodeBuilder_Table = root::tflite::OperatorCode;
        impl Default for OperatorCodeBuilder {
            fn default() -> Self {
                let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
                unsafe {
                    ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
                    s.assume_init()
                }
            }
        }
        #[repr(C)]
        pub struct OperatorT {
            pub opcode_index: u32,
            pub inputs: root::std::vector,
            pub outputs: root::std::vector,
            pub builtin_options: root::tflite::BuiltinOptionsUnion,
            pub custom_options: root::std::vector,
            pub custom_options_format: root::tflite::CustomOptionsFormat,
            pub mutating_variable_inputs: [u32; 5usize],
            pub intermediates: root::std::vector,
            pub large_custom_options_offset: u64,
            pub large_custom_options_size: u64,
            pub builtin_options_2: root::tflite::BuiltinOptions2Union,
        }
        pub type OperatorT_TableType = root::tflite::Operator;
        impl Default for OperatorT {
            fn default() -> Self {
                let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
                unsafe {
                    ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
                    s.assume_init()
                }
            }
        }
        impl ::core::fmt::Debug for OperatorT {
            fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                write ! (f , "OperatorT {{ inputs: {:?}, outputs: {:?}, builtin_options: {:?}, custom_options: {:?}, custom_options_format: {:?}, mutating_variable_inputs: opaque, intermediates: {:?}, builtin_options_2: {:?} }}" , self . inputs , self . outputs , self . builtin_options , self . custom_options , self . custom_options_format , self . intermediates , self . builtin_options_2)
            }
        }
        #[repr(C)]
        #[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
        pub struct Operator {
            pub _base: root::flatbuffers::Table,
        }
        pub type Operator_NativeTableType = root::tflite::OperatorT;
        pub type Operator_Builder = root::tflite::OperatorBuilder;
        #[repr(u16)]
        #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
        pub enum Operator_FlatBuffersVTableOffset {
            VT_OPCODE_INDEX = 4,
            VT_INPUTS = 6,
            VT_OUTPUTS = 8,
            VT_BUILTIN_OPTIONS_TYPE = 10,
            VT_BUILTIN_OPTIONS = 12,
            VT_CUSTOM_OPTIONS = 14,
            VT_CUSTOM_OPTIONS_FORMAT = 16,
            VT_MUTATING_VARIABLE_INPUTS = 18,
            VT_INTERMEDIATES = 20,
            VT_LARGE_CUSTOM_OPTIONS_OFFSET = 22,
            VT_LARGE_CUSTOM_OPTIONS_SIZE = 24,
            VT_BUILTIN_OPTIONS_2_TYPE = 26,
            VT_BUILTIN_OPTIONS_2 = 28,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq, Eq)]
        pub struct OperatorBuilder {
            pub fbb_: *mut root::flatbuffers::FlatBufferBuilder,
            pub start_: root::flatbuffers::uoffset_t,
        }
        pub type OperatorBuilder_Table = root::tflite::Operator;
        impl Default for OperatorBuilder {
            fn default() -> Self {
                let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
                unsafe {
                    ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
                    s.assume_init()
                }
            }
        }
        #[repr(C)]
        pub struct SubGraphT {
            pub tensors: root::std::vector,
            pub inputs: root::std::vector,
            pub outputs: root::std::vector,
            pub operators: root::std::vector,
            pub name: root::std::string,
        }
        pub type SubGraphT_TableType = root::tflite::SubGraph;
        impl Default for SubGraphT {
            fn default() -> Self {
                let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
                unsafe {
                    ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
                    s.assume_init()
                }
            }
        }
        impl ::core::fmt::Debug for SubGraphT {
            fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                write ! (f , "SubGraphT {{ tensors: {:?}, inputs: {:?}, outputs: {:?}, operators: {:?}, name: {:?} }}" , self . tensors , self . inputs , self . outputs , self . operators , self . name)
            }
        }
        #[repr(C)]
        #[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
        pub struct SubGraph {
            pub _base: root::flatbuffers::Table,
        }
        pub type SubGraph_NativeTableType = root::tflite::SubGraphT;
        pub type SubGraph_Builder = root::tflite::SubGraphBuilder;
        #[repr(u16)]
        #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
        pub enum SubGraph_FlatBuffersVTableOffset {
            VT_TENSORS = 4,
            VT_INPUTS = 6,
            VT_OUTPUTS = 8,
            VT_OPERATORS = 10,
            VT_NAME = 12,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq, Eq)]
        pub struct SubGraphBuilder {
            pub fbb_: *mut root::flatbuffers::FlatBufferBuilder,
            pub start_: root::flatbuffers::uoffset_t,
        }
        pub type SubGraphBuilder_Table = root::tflite::SubGraph;
        impl Default for SubGraphBuilder {
            fn default() -> Self {
                let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
                unsafe {
                    ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
                    s.assume_init()
                }
            }
        }
        #[repr(C)]
        pub struct BufferT {
            pub data: root::std::vector,
            pub offset: u64,
            pub size: u64,
        }
        pub type BufferT_TableType = root::tflite::Buffer;
        impl Default for BufferT {
            fn default() -> Self {
                let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
                unsafe {
                    ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
                    s.assume_init()
                }
            }
        }
        impl ::core::fmt::Debug for BufferT {
            fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                write!(f, "BufferT {{ data: {:?} }}", self.data)
            }
        }
        #[repr(C)]
        #[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
        pub struct Buffer {
            pub _base: root::flatbuffers::Table,
        }
        pub type Buffer_NativeTableType = root::tflite::BufferT;
        pub type Buffer_Builder = root::tflite::BufferBuilder;
        #[repr(u16)]
        #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
        pub enum Buffer_FlatBuffersVTableOffset {
            VT_DATA = 4,
            VT_OFFSET = 6,
            VT_SIZE = 8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq, Eq)]
        pub struct BufferBuilder {
            pub fbb_: *mut root::flatbuffers::FlatBufferBuilder,
            pub start_: root::flatbuffers::uoffset_t,
        }
        pub type BufferBuilder_Table = root::tflite::Buffer;
        impl Default for BufferBuilder {
            fn default() -> Self {
                let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
                unsafe {
                    ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
                    s.assume_init()
                }
            }
        }
        #[repr(C)]
        pub struct MetadataT {
            pub name: root::std::string,
            pub buffer: u32,
        }
        pub type MetadataT_TableType = root::tflite::Metadata;
        impl Default for MetadataT {
            fn default() -> Self {
                let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
                unsafe {
                    ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
                    s.assume_init()
                }
            }
        }
        impl ::core::fmt::Debug for MetadataT {
            fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                write!(f, "MetadataT {{ name: {:?} }}", self.name)
            }
        }
        #[repr(C)]
        #[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
        pub struct Metadata {
            pub _base: root::flatbuffers::Table,
        }
        pub type Metadata_NativeTableType = root::tflite::MetadataT;
        pub type Metadata_Builder = root::tflite::MetadataBuilder;
        #[repr(u16)]
        #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
        pub enum Metadata_FlatBuffersVTableOffset {
            VT_NAME = 4,
            VT_BUFFER = 6,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq, Eq)]
        pub struct MetadataBuilder {
            pub fbb_: *mut root::flatbuffers::FlatBufferBuilder,
            pub start_: root::flatbuffers::uoffset_t,
        }
        pub type MetadataBuilder_Table = root::tflite::Metadata;
        impl Default for MetadataBuilder {
            fn default() -> Self {
                let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
                unsafe {
                    ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
                    s.assume_init()
                }
            }
        }
        #[repr(C)]
        pub struct TensorMapT {
            pub name: root::std::string,
            pub tensor_index: u32,
        }
        pub type TensorMapT_TableType = root::tflite::TensorMap;
        impl Default for TensorMapT {
            fn default() -> Self {
                let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
                unsafe {
                    ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
                    s.assume_init()
                }
            }
        }
        impl ::core::fmt::Debug for TensorMapT {
            fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                write!(f, "TensorMapT {{ name: {:?} }}", self.name)
            }
        }
        #[repr(C)]
        #[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
        pub struct TensorMap {
            pub _base: root::flatbuffers::Table,
        }
        pub type TensorMap_NativeTableType = root::tflite::TensorMapT;
        pub type TensorMap_Builder = root::tflite::TensorMapBuilder;
        #[repr(u16)]
        #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
        pub enum TensorMap_FlatBuffersVTableOffset {
            VT_NAME = 4,
            VT_TENSOR_INDEX = 6,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq, Eq)]
        pub struct TensorMapBuilder {
            pub fbb_: *mut root::flatbuffers::FlatBufferBuilder,
            pub start_: root::flatbuffers::uoffset_t,
        }
        pub type TensorMapBuilder_Table = root::tflite::TensorMap;
        impl Default for TensorMapBuilder {
            fn default() -> Self {
                let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
                unsafe {
                    ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
                    s.assume_init()
                }
            }
        }
        #[repr(C)]
        pub struct SignatureDefT {
            pub inputs: root::std::vector,
            pub outputs: root::std::vector,
            pub signature_key: root::std::string,
            pub subgraph_index: u32,
        }
        pub type SignatureDefT_TableType = root::tflite::SignatureDef;
        impl Default for SignatureDefT {
            fn default() -> Self {
                let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
                unsafe {
                    ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
                    s.assume_init()
                }
            }
        }
        impl ::core::fmt::Debug for SignatureDefT {
            fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                write!(
                    f,
                    "SignatureDefT {{ inputs: {:?}, outputs: {:?}, signature_key: {:?} }}",
                    self.inputs, self.outputs, self.signature_key
                )
            }
        }
        #[repr(C)]
        #[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
        pub struct SignatureDef {
            pub _base: root::flatbuffers::Table,
        }
        pub type SignatureDef_NativeTableType = root::tflite::SignatureDefT;
        pub type SignatureDef_Builder = root::tflite::SignatureDefBuilder;
        #[repr(u16)]
        #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
        pub enum SignatureDef_FlatBuffersVTableOffset {
            VT_INPUTS = 4,
            VT_OUTPUTS = 6,
            VT_SIGNATURE_KEY = 8,
            VT_SUBGRAPH_INDEX = 12,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq, Eq)]
        pub struct SignatureDefBuilder {
            pub fbb_: *mut root::flatbuffers::FlatBufferBuilder,
            pub start_: root::flatbuffers::uoffset_t,
        }
        pub type SignatureDefBuilder_Table = root::tflite::SignatureDef;
        impl Default for SignatureDefBuilder {
            fn default() -> Self {
                let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
                unsafe {
                    ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
                    s.assume_init()
                }
            }
        }
        #[repr(C)]
        pub struct ModelT {
            pub version: u32,
            pub operator_codes: root::std::vector,
            pub subgraphs: root::std::vector,
            pub description: root::std::string,
            pub buffers: root::std::vector,
            pub metadata_buffer: root::std::vector,
            pub metadata: root::std::vector,
            pub signature_defs: root::std::vector,
        }
        pub type ModelT_TableType = root::tflite::Model;
        impl Default for ModelT {
            fn default() -> Self {
                let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
                unsafe {
                    ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
                    s.assume_init()
                }
            }
        }
        impl ::core::fmt::Debug for ModelT {
            fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                write ! (f , "ModelT {{ operator_codes: {:?}, subgraphs: {:?}, description: {:?}, buffers: {:?}, metadata_buffer: {:?}, metadata: {:?}, signature_defs: {:?} }}" , self . operator_codes , self . subgraphs , self . description , self . buffers , self . metadata_buffer , self . metadata , self . signature_defs)
            }
        }
        #[repr(C)]
        #[repr(align(1))]
        #[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
        pub struct Model {
            pub _bindgen_opaque_blob: u8,
        }
        pub type Model_NativeTableType = root::tflite::ModelT;
        pub type Model_Builder = root::tflite::ModelBuilder;
        #[repr(u16)]
        #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
        pub enum Model_FlatBuffersVTableOffset {
            VT_VERSION = 4,
            VT_OPERATOR_CODES = 6,
            VT_SUBGRAPHS = 8,
            VT_DESCRIPTION = 10,
            VT_BUFFERS = 12,
            VT_METADATA_BUFFER = 14,
            VT_METADATA = 16,
            VT_SIGNATURE_DEFS = 18,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq, Eq)]
        pub struct ModelBuilder {
            pub fbb_: *mut root::flatbuffers::FlatBufferBuilder,
            pub start_: root::flatbuffers::uoffset_t,
        }
        pub type ModelBuilder_Table = root::tflite::Model;
        impl Default for ModelBuilder {
            fn default() -> Self {
                let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
                unsafe {
                    ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
                    s.assume_init()
                }
            }
        }
        #[repr(C)]
        #[repr(align(4))]
        pub struct MicroInterpreter {
            pub _bindgen_opaque_blob: [u32; 48usize],
        }
        impl Default for MicroInterpreter {
            fn default() -> Self {
                let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
                unsafe {
                    ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
                    s.assume_init()
                }
            }
        }
        impl ::core::fmt::Debug for MicroInterpreter {
            fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                write!(f, "MicroInterpreter {{ opaque }}")
            }
        }
        pub mod ops {
            #[allow(unused_imports)]
            use self::super::super::super::root;
        }
        pub mod reference_ops {
            #[allow(unused_imports)]
            use self::super::super::super::root;
        }
        #[repr(C)]
        #[repr(align(4))]
        #[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
        pub struct MicroErrorReporter {
            pub _bindgen_opaque_blob: u32,
        }
    }
    pub mod ruy {
        #[allow(unused_imports)]
        use self::super::super::root;
    }
}
